---
title: 浅入 JavaScript 如何执行
date: 2020-03-25
author: ahabhgk
description: 一段 JavaScript 代码究竟如何执行，在一定抽象层次上简单完整的讲解，对执行上下文、this、异步、Web API、执行栈、任务队列进行一个完成的串联
tags:
  - Thinking
  - JavaScript
---

import { CodeWave } from 'gatsby-theme-waves'

理解一段 JavaScript 代码究竟，对于很多概念的理解都是有帮助的，本文会通过多个例子串联 JavaScript 中初学者晦涩难懂的那些概念

## 执行栈和任务队列

JavaScript 的执行环境中存在两个东西，一个是执行栈，用于存储执行上下文，解决变量的值是什么的问题，另一个是任务队列，用于任务调度，解决单线程中异步代码执行顺序的问题

我们先来讲清楚执行栈，之后在加入任务队列，要知道这两个东西是同时存在的，一开始我们忽略任务队列只是为了更清晰的讲解

## 执行栈

就是一个栈呗，LIFO 后进先出，JS 中使用链表实现，没什么神奇的

### 执行上下文

JS 中有三种执行上下文

- 全局执行上下文：是最基本的环境，用于存储全局的变量，一个程序中只有一个全局上下文，位于执行栈的最底下。全局变量中的 this 指向 globalThis（具体视情况而定），outer 为 null

- 函数执行上下文：当函数被调用时会产生一个函数执行上下文，放到执行栈的上面，它的 this 根据 ThisBinding 确定，outer 指向栈的上一个执行上下文，相对于全局执行上下文可以有多个

- eval 函数执行上下文：正常的 JS 程序是没有 eval 的，所以忽略它

### 执行上下文的创建与执行

会做两件事：

1. 创建 LexicalEnvironment 词法环境

2. 创建 VariableEnvironment 变量环境

我们来看一个简单的例子

```js
let a = 20
const b = 30
var c
const d = { num: 1 }

function calc(e, obj) {
  var f = 20
  return e * f * b * obj.num
}

c = calc(a， d)
```

<CodeWave>

```js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      a: <uninitialized>,
      b: <uninitialized>,
      d: <uninitialized>,
      calc: function calc(e, obj) {
        // ...
      },
    },
    outer: null,
    ThisBinding: window,
  },
  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      c: undefined,
    },
    outer: null,
    ThisBinding: window,
  },
}
```

首先代码还没有运行，先是全局执行上下文的创建，我们假设这段代码处于浏览器非严格环境下，由于处于执行栈底部，所以 outer 是 null，ThisBinding 指向 window 对象

对于全局执行上下文的 EnvironmentRecord.Type 是一个 "Object"，从上到下声明变量，对于 let、const 声明的变量放到 LexicalEnvironment，标记 `<uninitialized>`，在未被赋值之前形成所谓的**暂时性死区**，function 声明同样放到 LexicalEnvironment 并直接赋值为该函数，并不会有什么 undefined、uninitialize，这就叫**函数提升**，对于 var 声明的放到 VariableEnvironment 值为 undefined，就叫**变量提升**

对于 var 声明是很有迷惑性的，`var a = 1; function a() {}` 这样 a 竟然是 1，这当然是变量提升函数提升搞的鬼。而只用 let、const、function 就正常多了，就像从上到下遇到 a 声明 a 遇到 b 声明 b 一样，但不要忘了使用 function 时的函数提升，暂时性死区配合函数提升才表现的正常点，所以暂时性死区也是为了填坑，如果当初设计时不搞什么提升自然也没有这么多莫名其妙的幺蛾子概念

```js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      a: 20,
      b: 30,
      d: { num: 1 },
      calc: function calc(e, obj) {
        // ...
      },
    },
    outer: null,
    ThisBinding: window,
  },
  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      c: undefined,
    },
    outer: null,
    ThisBinding: window,
  },
}
```

之后代码运行，a 赋值 b 赋值…… ，运行到最后一行之前是这样的

```js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      a: 20,
      b: 30,
      d: { num: 1 },
      calc: function calc(e, obj) {
        // ...
      },
    },
    outer: null,
    ThisBinding: window,
  },
  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      c: undefined,
    },
    outer: null,
    ThisBinding: window,
  },
}

FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      Arguments: { 0: 20, 1: &d, length: 2 },
    },
    outer: GlobalExectionContext,
    ThisBinding: window,
  },
  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      f: undefined
    },
    outer: GlobalExectionContext,
    ThisBinding: window,
  }
}
```

然后代码运行最后一行函数调用，产生一个函数执行上下文，加到执行栈的上面，outer 指向其执行栈下面一层也就是 GlobalExectionContext，ThisBinding 由于只是函数调用就指向 window

函数调用中的 EnvironmentRecord 为 "Declarative"，Arguments 声明到 LexicalEnvironment 中，参数 e 是原始类型，所以 Arguments.0 是实参 a 的值 20，参数 obj 是引用类型，Arguments.1 就是实参 d 的值也就是 `{ num: 1 }` 地址，这就是**函数参数的值传递**，因此函数中对于参数是对象时修改其属性会对原本对象产生影响（参数的那个对象 === 原本对象）。之后 var 声明变量 f 变量提升为 undefined

```js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      a: 20,
      b: 30,
      d: { num: 1 },
      calc: function calc(e, obj) {
        // ...
      },
    },
    outer: null,
    ThisBinding: window,
  },
  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      c: undefined,
    },
    outer: null,
    ThisBinding: window,
  },
}

FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      Arguments: { 0: 20, 1: &d, length: 2 },
    },
    outer: GlobalExectionContext,
    ThisBinding: window,
  },
  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      f: 20,
    },
    outer: GlobalExectionContext,
    ThisBinding: window,
  }
}
```

然后调用函数中的代码，g 赋值为 20，`return e * f * b * obj.num` 中 f 从函数执行上下文中得到，b 由于在函数执行上下文中没有找到会根据 outer 向执行栈的下一层寻找，就像个单向链表（原型链也是个单向链表），终于在 GlobalExectionContext 得到，之后算出值然后 return

```js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      a: 20,
      b: 30,
      d: { num: 1 },
      calc: function calc(e, obj) {
        // ...
      },
    },
    outer: null,
    ThisBinding: window,
  },
  VariableEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      c: 12000,
    },
    outer: null,
    ThisBinding: window,
  },
}
```

最后函数调用完毕，函数执行上下文出栈，c 赋值，OK 没了

</CodeWave>

可以看出 VariableEnvironment 其实是为了存储 var 声明的变量，LexicalEnvironment 为了存储 let、const 声明的变量，其他没有区别，现在也都是 ES6 的写法，后面为了简洁我们会省略 VariableEnvironment

### 闭包 Closure

函数 return 之后函数执行上下文会出栈，可为什么返回一个函数时仍能够访问到之前函数执行上下文中的变量呢，是因为函数执行上下文会变成一个 ClosureScope 闭包

```js
const add = a => b => a + b
add(3)(2)
```

<CodeWave>

```js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      add: a => b => a + b,
    },
    outer: null,
    ThisBinding: undefined,
  },
}

// a => b => a + b
FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      a: 3,
    },
    outer: GlobalExectionContext,
  },
}
```

先是 add(3) 这里，返回 `b => a + b`

```js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      add: a => b => a + b,
    },
    outer: null,
    ThisBinding: undefined,
  },
}

// a => b => a + b
ClosureScope = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      a: 3,
    },
    outer: GlobalExectionContext,
  },
}

// b => a + b
FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      b: 2,
    },
    outer: ClosureScope,
  },
}
```

之后调用 add(3)(2)，此时由于仍然需要上一个函数执行上下文的变量，形成一个闭包，通过 outer 访问到闭包中的 a 的值，得到结果并返回

</CodeWave>

### ThisBinding

算上 ES6 箭头函数就一共有 5 中 this 绑定方式，直接看一个例子，理解两种比较坑的：

```js
const a = {
  a: 'a',
}
class Obj {
  getThisByArrowFn = () => this
  getThisByFn() {
    return this
  }
}
const obj = new Obj()
obj.getThisByBindFn = obj.getThisByFn.bind(obj)

obj.getThisByArrowFn() // obj
obj.getThisByBindFn.call(a) // obj
```

<CodeWave>

```js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      a: {
        a: 'a',
      },
      Obj: class Obj {/* */},
      obj: <uninitialized>,
    },
    outer: null,
    ThisBinding: undefined,
  },
}

FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      Arguments: { length: 0 },
    },
    outer: GlobalExectionContext,
    ThisBinding: obj,
  },
}
```

new Obj 调用时，obj 还是 uninitialized，由于用到 class 所以是严格模式，此时 GlobalExectionContext 的 ThisBinding 是 undefined，由于是 **new 绑定**此时构造函数 constructor 执行上下文的 ThisBinding 为 obj

```js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      a: {
        a: 'a',
        getThisByBindArrowFn,
        getThisByFnOnObj,
      },
      Obj: class Obj {/* */},
      obj: {
        getThisByArrowFn,
        getThisByFn,
      },
    },
    outer: null,
    ThisBinding: undefined,
  },
}

ClosureScope = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      Arguments: { length: 0 },
    },
    outer: GlobalExectionContext,
    ThisBinding: obj,
  },
}
```

构造函数隐式返回 this，obj 赋值为 this，由于有 `this.getThisByArrowFn = () => this` 形成了闭包

```js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      a: {
        a: 'a',
        getThisByBindArrowFn,
        getThisByFnOnObj,
      },
      Obj: class Obj {/* */},
      obj: {
        getThisByArrowFn,
        getThisByFn,
      },
    },
    outer: null,
    ThisBinding: undefined,
  },
}

ClosureScope = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      Arguments: { length: 0 },
    },
    outer: GlobalExectionContext,
    ThisBinding: obj,
  },
}

// obj.getThisByFn.bind(obj)
FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      Arguments: { 0: &obj, length: 1 },
    },
    outer: GlobalExectionContext,
    ThisBinding: obj, // 显式 bind 到 obj
  },
}
```

之后 `obj.getThisByBindFn = obj.getThisByFn.bind(obj)` 调用 bind 进行**显式绑定**，返回一个确定 ThisBinding 指向 obj 的函数

```js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      a: {
        a: 'a',
        getThisByBindArrowFn,
        getThisByFnOnObj,
      },
      Obj: class Obj {/* */},
      obj: {
        getThisByArrowFn,
        getThisByFn,
      },
    },
    outer: null,
    ThisBinding: undefined,
  },
}

ClosureScope = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      Arguments: { length: 0 },
    },
    outer: GlobalExectionContext,
    ThisBinding: obj,
  },
}

// obj.getThisByArrowFn()
FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
    },
    outer: ClosureScope,
  },
}
```

之后调用 `obj.getThisByArrowFn()`，由于箭头函数没有 this，所以通过 outer 找到闭包环境中的 ThisBinding，所以输出 obj


```js
GlobalExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Object",
      a: {
        a: 'a',
        getThisByBindArrowFn,
        getThisByFnOnObj,
      },
      Obj: class Obj {/* */},
      obj: {
        getThisByArrowFn,
        getThisByFn,
      },
    },
    outer: null,
    ThisBinding: undefined,
  },
}

ClosureScope = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      Arguments: { length: 0 },
    },
    outer: GlobalExectionContext,
    ThisBinding: obj,
  },
}

// obj.getThisByBindFn.call(a)
FunctionExectionContext = {
  LexicalEnvironment: {
    EnvironmentRecord: {
      Type: "Declarative",
      Arguments: { 0: &obj, length: 1 },
    },
    outer: ClosureScope,
    ThisBinding: obj,
  },
}
```

之后调用 `obj.getThisByBindFn.call(a)`，由于 obj 的 getThisByBindFn 已经用 bind 绑定过 this，call 再绑定没用，所以仍然是 obj

</CodeWave>

## 任务队列

任务队列分为宏任务和微任务，一个宏任务执行之后会依次执行完所有的微任务，之后再执行宏任务，以此循环，也并不难，来看一个例子理解异步中为什么不能 try / catch

// TODO: 补充宏任务微任务，I/O、UI Rendering、Web API……

```js
try {
  setTimeout(() => throw new Error('hah'), 0)
} catch (e) {}
```

这里执行到 setTimeout 在 0 ms 后将回调函数加入任务队列，// TODO

## ref

[Understanding Execution Context and Execution Stack in Javascript](https://blog.bitsrc.io/understanding-execution-context-and-execution-stack-in-javascript-1c9ea8642dd0)

[What is `this`? The Inner Workings of JavaScript Objects](https://medium.com/javascript-scene/what-is-this-the-inner-workings-of-javascript-objects-d397bfa0708a)

[Difference between microtask and macrotask within an event loop context](https://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context)