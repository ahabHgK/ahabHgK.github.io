---
title: Accumulator
slug: oip-accumulator
date: 2020-04-16
description: 面向面试学习
tags:
  - Interview
---

## HTTP

### Content 系列字段

TCP / UDP 由于是传输层协议，并不关心传输的数据，只关心传输，而 HTTP 是应用层协议，需要关心数据是什么，告诉上层应用数据类型、压缩方式、语言类型

1. 数据类型

多种格式的数据传输到客户端，客户端最低效的方式是根据前几个字节直接猜，更高效的方式是通过指定数据类型告诉客户端是什么格式

MIME 之前是用在电子邮件系统里的，让电子邮件可以发送 ASCII 码以外的任意数据，常用的有：text/html、text/plain、text/css、image/gif、image/jpeg、image/png、audio/mpeg、video/mp4、application/json，application/javascript、application/pdf、application/octet-stream（不透明的二进制数据）

客户端发送请求带有 Accept 头部字段标记可理解的数据类型：`Accept: text/html,application/xml,image/webp,image/png`，服务器会在响应报文里用头字段 Content-Type 告诉实体数据的真实类型：`Content-Type: text/html`

2. 压缩方式

HTTP 在传输时为了节约带宽，有时候还会压缩数据，为了不要让浏览器继续“猜”，还需要有一个“Encoding type”

常用压缩格式：gzip、deflate、br（一种专门为 HTTP 优化的新压缩算法 Brotli）

客户端通过 Accept-Encoding 标记客户端支持的压缩格式：`Accept-Encoding: gzip, deflate, br`，服务器实际使用的压缩格式放在响应头字段 Content-Encoding：`Content-Encoding: gzip`

3. 语言类型和字符集

Accept-Language 字段标记了客户端可理解的自然语言：`Accept-Language: zh-CN, zh, en`（最好给我 zh-CN 的汉语文字，如果没有就用其他的汉语方言，如果还没有就给英文），服务器应该在响应报文里用头字段 Content-Language 告诉客户端实体数据使用的实际语言类型：`Content-Language: zh-CN`

字符集在 HTTP 里使用的请求头字段是 Accept-Charset：`Accept-Charset: gbk, utf-8`，响应头中放在 Content-Type 中：`ontent-Type: text/html; charset=utf-8`

4. 内容协商

Accept、Accept-Encoding、Accept-Language 等请求头字段进行内容协商的时候，还可以用一种特殊的“q”参数表示权重来设定优先级

权重的最大值是 1，最小值是 0.01，默认值是 1，如果值是 0 就表示拒绝

`Accept: text/html,application/xml;q=0.9,*/*;q=0.8` 表示客户端最希望 html 格式，权重 1，其次 xml 权重 0.9，最后任意类型权重 0.8

内容协商的过程是不透明的，每个 Web 服务器使用的算法都不一样，但有的时候，服务器会在响应头里多加一个 Vary 字段，记录服务器在内容协商时参考的请求头字段：`Vary: Accept-Encoding,User-Agent,Accept`

### HTTP 大文件传输

压缩传输、分批传输、范围请求

#### Transfer-Encoding: chunked 不定长数据 Content-Length 定长数据

对于定长数据添加 Content-Length 响应头

```js
res.setHeader('Content-Type', 'text/plain')
res.setHeader('Content-Length', 10)
res.write("helloworld")
```

如果 length 小于真实长度会截断，大于真实长度会直接无法显示

对于不定长数据需要 `Transfer-Encoding: chunked` 响应头，与 Content-Length 互斥

```js
res.setHeader('Content-Type', 'text/html; charset=utf8')
res.setHeader('Content-Length', 10)
res.setHeader('Transfer-Encoding', 'chunked')
res.write("<p>来啦</p>")
setTimeout(() => {
  res.write("第一次传输<br />")
}, 1000)
setTimeout(() => {
  res.write("第二次传输")
  res.end()
}, 2000)
```

![chunked](./images/chunked.gif)

响应题格式：其中 length 是 16 进制数字表示长度，最后用一个长度为 0 的块表示结束，即“0\r\n\r\n”

![](./images/chunked-format.png)

使用 telnet 看格式：

```http
HTTP/1.1 200 OK
Content-Type: text/html; charset=utf8
Content-Length: 10
Transfer-Encoding: chunked
Date: Sun, 23 Feb 2020 11:06:31 GMT
Connection: keep-alive

d
<p>来啦</p>
14
第一次传输<br />
f
第二次传输
0
```

#### Range 范围请求

不是必备的，所以服务器必须在响应头中添加 `Accept-Ranges: bytes` 告诉客户端支持范围请求，如果不支持需要用 `Accept-Ranges: none` 或不添加该字段

比如看视频时，想要跳过一部分

```http
GET /16-2 HTTP/1.1
Host: ahabhgk.top/ranging
Range: bytes=30-39
```

```http
HTTP/1.1 206 Partial Content
Content-Length: 10
Accept-Ranges: bytes
Content-Range: bytes 30-39/100

// video data...
```

其中 `Range: bytes=30-39` 表示偏移量，从 30 开始到 39 一共 10 个字节，格式还可以是“10-”表示“10-99”、“-10”表示“90-99”

服务器收到 Range 后检测范围是否合法，超出就会返回 416，如果正确就返回“206 Partial Content”并添加 Content-Range 表示片段的实际偏移量和资源的总大小

不仅看视频的拖拽进度需要范围请求，常用的下载工具里的多段下载、断点续传也是基于它实现的，要点是：

1. 先发个 HEAD，看服务器是否支持范围请求，同时获取文件的大小

2. 多个请求使用 Range 字段划分出各自负责下载的片段，发请求传输数据

3. 下载意外中断也不怕，不必重头再来一遍，只要根据上次的下载记录，用 Range 请求剩下的那一部分

当 Range 用逗号隔开分为多段时，可以一次性请求多个数据片段，此时需要 multipart/byteranges 表示报文的 body 是由多段字节序列组成的，并通过 boundary 分割

![multipart](./images/multipart.png)

```http
GET /16-2 HTTP/1.1
Host: ahabhgk.top/ranging
Range: bytes=0-9, 20-29
```

```http
HTTP/1.1 206 Partial Content
Content-Type: multipart/byteranges; boundary=00000000001
Content-Length: 189
Connection: keep-alive
Accept-Ranges: bytes


--00000000001
Content-Type: text/plain
Content-Range: bytes 0-9/96

// this is
--00000000001
Content-Type: text/plain
Content-Range: bytes 20-29/96

ext json d
--00000000001--
```

### Connection: keep-alive 长连接

响应头 `Connection: keep-alive` HTTP/1.1 默认添加

长连接对于短连接性能更好，但是也有一些缺点：TCP 连接长时间不关闭，服务器必须在内存里保存它的状态，这就占用了服务器的资源。如果有大量的空闲长连接只连不发，就会很快耗尽服务器的资源，导致服务器无法为真正有需要的用户提供服务

关闭长连接：

1. 对于关闭长连接可以在请求头中添加 `Connection: close` 字段，服务器看到后就会关闭连接并在响应头中也添加这个字段

2. 服务器端通常不会主动关闭连接，Nginx 可以使用 keepalive_timeout 指令设置长连接的超时时间，keepalive_requests 指令设置长连接上可发送的最大请求次数

3. 客户端和服务器都可以在报文里附加通用头字段 `Keep-Alive: timeout=60`，但该字段约束力不强

> Connection: Upgrade 配合 101 表示协议升级，比如 HTTP 升级 WebSocket

### 如何解决对头阻塞

因为 HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求没有轻重缓急的优先级，只有入队的先后顺序，排在最前面的请求被最优先处理，对首的处理太慢就会阻塞后面的

1. 并发连接，一个域名发起多个长连接，但如果过多服务器扛不住，可能被认为恶意攻击造成拒绝访问，所以规范限制一个客户端最多并发两个长连接，但仍然不够用，浏览器实现为 6-8 个，之后修订的规范也取消了两个的限制

2. 域名分片，由于限制并发连接数量，那就多开几个域名都指向同一个服务器

