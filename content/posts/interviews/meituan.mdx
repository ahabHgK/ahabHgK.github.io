---
title: 美团面试准备
date: 2020-04-04
description: 美团面试准备
tags:
  - Note
  - Interview
---

## 谈谈你对 TCP 三次握手和四次挥手的理解

- 三次握手：第一次客户端发送，问服务端能不能通信，服务端回答可以，这是第二次，这次用来告诉客户端：客户端像服务端发送是 OK 的，然后客户端回答收到，这是第三次，这次用来告诉服务端：服务端向客户端发送是 OK 的。所以三次是最少的且安全的次数

- 四次挥手：TCP 是全双工的，就是客户端的输出连接服务端的输入这一条通道，客户端的输入连接服务端的输出这一条通道，当断开时需要先是客户端输出断开，服务端也断开这条通道，然后服务端输出断开，客户端也断开这条通道

## 简单讲解一下 http2 的多路复用

主要是解决 http1.1 中的性能问题，http1.0 中一个请求建立一个 TCP 连接，每次都要进行三次握手四次挥手，如果一个 TCP 连接对应多个 http 请求就需要开启 Connection: Keep-Alive，到了 http1.1 时默认开启 Keep-Alive，解决了多次连接的问题，但是依然有队头阻塞的问题，由于 http1.1 中需要数据有序，所以请求是串行的，必须等下上一个请求接受才能发起下一个请求

而 http2 中的数据会拆分成二进制数据帧，每个二进制帧的头部会标示自己属于哪个流，通过多个流传输到服务端，然后服务端将流中的帧重新组合成完整的数据，所以这些帧是可以交错传输，就可以同时传输多个数据流，**多路复用指的就是一个 TCP 连接有多条流**，这样就解决了队头阻塞的问题

（但 http2 仍然基于 TCP，TCP 为了保证不丢包仍然会有阻塞问题，http3 就基于 UDP 解决了这个问题）

## React 中 setState 什么时候是同步的，什么时候是异步的

在 React 合成事件和生命周期钩子中是异步的，在 setTimeout 和原生事件中是同步的

setState 的异步并不是真正的异步，没有产生宏任务微任务，只是 setState 之后再次访问 state 不会立即得到改变后的 state，表现的像是异步而已，由于有一个 batch 的过程，将多个 setState 合并（类似于 Object.assign）如果使用 setState 的 callback 则可以访问到改变后的 state

## CommonJS 和 ES6 的模块化的差异

- ES6 的是对值得引用，CommomJS 是对值的拷贝（会缓存）

- CommomJS 运行时加载，加载的是一个对象，ES6 的是编译时输出接口，在代码解析时生成的静态定义

对服务器来说由于模块在本地同时启动后不会关会有缓存，同步加载没问题，所以 CommonJS 是同步加载，浏览器由于模块在服务器上，同步加载会阻塞所以不能同步加载，ES6 并没有强行指定同步或异步，但由于 `<script type="module" src="..."></script>` 等同于带有 defer 所以是异步加载的

## script 标签带有 defer 和 async 时的差异

在网络下载时都不会阻塞 HTML 解析，defer 按照加载顺序在 HTML 解析完成后执行脚本，而 async 在加载完成后就会执行，会阻塞 HTML 解析，同时由于脚本加载时间不确定，所以执行也是乱序的

## XSS

恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行

- 反射型：构造出特殊的 URL（比如 `?type=<script>alert('bad')</script>`），访问后服务端返回 type 的内容到页面上执行

- DOM 型：使用 .innerHTML、.outerHTML、.appendChild、document.write() 等 API 时把不可信的内容插入到了页面，尽量使用 .innerText、.textContent、.setAttribute()

- 存储型：恶意脚本永久存储在目标服务器上

防范：encodeURIComponent 转义 URL 链接、非 URL 将 " ' < > 进行转义、添加 CSP meta 标签或 Response header 控制页面能加载哪些资源、限制内容长度

> `Content-Security-Policy: default-src 'self'`
>
> `<meta http-equiv="Content-Security-Policy" content="form-action 'self';">`

## CSRF

在用户登录 A 网站后诱导其进入 B 网站，B 网站发送 A 网站的请求，会带上 Cookie，B 网站冒充用户完成了攻击

防范：验证码、检测 Referer，但 Referer 可以被修改、token、SameSite Cookie

## HTTPS

> [一次安全可靠的通信——HTTPS原理](https://developers.weixin.qq.com/community/develop/article/doc/000046a5fdc7802a15f7508b556413)

对称加密：加密解密运用同一个密钥（Hacker 在互相告知密钥的时候提前获取密钥）

非对称加密：任何人可以拿公钥加密，自己拿私钥解密（性能差，Hacker 用自己的公钥私钥在中间转发）

认证：CA 制作证书，一方通过发送证书（自己的公钥 + CA 数字签名（CA 的私钥加密公钥解密）），另一方用 CA 的公钥解密 CA 数字签名验证是否有 Hacker 转发（Hacker 虽然不能修改但仍可以破坏数据）

完整性：单向 Hash 算法得到 hash 并发送，另一方验证得到内容的 hash 跟收到的 hash 是否一致验证完整性

https：三次握手 => SSL 握手 => 加密通信并用 hash 验证完整性

SSL 握手：

1. 浏览器发送请求到服务器，包括支持的加密算法列表和随机数 random1

2. 服务器确认加密通信协议版本是否一致，是则回应证书（非对称加密的公钥和 CA 数字签名）、随机数 random2 和选择的加密算法，否则关闭加密通信

3. 浏览器通过已有的 CA 公钥解密 CA 数字签名验证证书是否失效，若失效则给提示决定是否继续连接，若没问题就产生一个随机数 pre-master 并用非对称加密的公钥加密，然后发送给服务器，同时 random1 + random2 + pre-master 生成 master-secret 对称加密的密钥用于后续数据传输

4. 服务端通过非对称加密的私钥解密得到 pre-master，用 random1 + random2 + pre-master 生成 master-secret 得到对称加密的密钥，并响应握手

## BFC

BFC 就是块级格式上下文，是页面盒模型布局中的一种 CSS 渲染模式，相当于一个独立的容器，里面的元素和外部的元素相互不影响，html 根元素、float 浮动、绝对定位、overflow 不为 visiable、display 为弹性布局可以创建 BFC

## 浏览器缓存

![cache](./src/images/cache.jpg)

缓存位置：

1. Service Worker：运行在浏览器背后的独立线程，是对请求的一种拦截，也因此必须是 https，首先需要注册 SW，install 事件后可以对资源进行缓存，之后 fetch 事件可以判断是否命中缓存，没有命中就可以调用 fetch 获取，可编程的控制缓存哪些文件、如何匹配缓存、如何读取缓存

2. Memory Cache：内存中的缓存，容量小访问快时效短

3. Disk Cache：磁盘中的缓存，强缓存和协商缓存就放到 Disk Cache 和 Memory Cache

4. Push Cache：http2 的，[HTTP/2 push is tougher than I thought](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/)

强缓存：

1. Cache-Control：http1.1 的

    - public：所有内容都将被缓存（客户端和代理服务器都可缓存）

    - private：所有内容只有客户端可以缓存

    - no-cache：在使用缓存数据时，需要先通过协商缓存确认是否与服务端一致

    - no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存

    - max-age：max-age=xxx，xxx 秒后失效

    - s-maxage：max-age用于普通缓存，而s-maxage用于代理缓存。s-maxage的优先级高于max-age

    - max-stale

    - min-fresh

2. Expires：http1.0 受限于本地时间 `Expires: Wed, 22 Oct 2018 08:41:00 GM`

协商缓存：

1. ETag 和 If-None-Match：服务器响应 header 中携带 Etag（根据文件内容生成的唯一标识），下一次请求时会在 header 中的 If-None-Match 携带，服务器根据比较 Etag 判断是否修改（是 200 否 304）

2. Last-Modified 和 If-Modified-Since：response header 携带 Last-Modified（最后修改时间，最小单位 s），下一次 request header 携带 If-Modified-Since，根据修改时间判断（不准确：本地打开文件没修改也会更新，以秒计时在很短时间修改完成）

## 数据埋点

new Image() 支持跨域，不占用 AJAX 请求，不用添加到 DOM 中不阻塞页面

## CDN

尽可能的在各个地方分布机房缓存数据

可以将静态资源尽量使用 CDN 加载，CDN 域名要与主站不同，否则每次请求都会带上主站的 Cookie，平白消耗流量

## React Hooks 解决什么问题

解决了组件之间复用状态逻辑难，之前的解决方案是 HOC 和 render props，很容易就出现很多层的嵌套，调试困难，复杂组件各种生命周期，一个渲染逻辑要在三个地方写，副作用混乱，class 本身 this 指向难理解

## React Hooks 原理



## 网络 4 层 7 层

![OSI](./src/images/OSI.png)

物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

- 链接层：负责在以太网、WiFi 这样的底层网络上发送原始数据包，使用 MAC 地址来标记网络上的设备

- 网络层：IP 协议就处在这一层，用 IP 地址取代 MAC 地址

- 传输层：这个层次协议的职责是保证数据在 IP 地址标记的两点之间“可靠”地传输

- 应用层：Telnet、SSH、FTP、SMTP、HTTP

## 白屏，从ISO七层每层进行分析

## UDP TCP 区别

TCP 是一个面向连接、可靠的、基于字节流的传输层协议

面向连接：三次握手

可靠的：精准记录数据是否到达，保证数据按顺序全部到达，当丢包或网络环境不佳时会控制自己发送速度或重发

UDP 是一个面向无连接的传输层协议

面向无连接：只是数据报文的搬运工（在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了；在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作）

不可靠性：无连接，不关心对方是否接收，没有拥塞控制，会一直以恒定的速度发送数据

高效：头部开销小

传输方式：一对一，一对多，多对多，多对一

## GET 和 POST 区别

从 RFC 规范上讲：

1. GET 能被缓存 POST 不能被缓存

2. POST 相对安全，GET 请求都包含在 URL 里

3. URL有长度限制，会影响 Get 请求，大多是浏览器和服务器的原因（性能和安全）

4. GET 数据类型只允许 ASCII 字符，POST 没有限制，也允许二进制数据

没有实质区别，只是报文不同：

请求行 GET POST 不一样，本质上是 TCP 连接，没有差别，也就是说，如果我不按规范来也是可以的。我们可以在 URL 上写参数，然后方法使用 POST；也可以在 Body 写参数，然后方法使用 GET。当然，这需要服务端支持

## XHR fetch 怎么取消和 timeout

## JWT

## 如何设计无缝轮播

## Promise

## 垃圾回收

## 自我介绍
