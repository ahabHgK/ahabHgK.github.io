{"componentChunkName":"component---node-modules-lekoarts-gatsby-theme-minimal-blog-core-src-templates-blog-query-tsx","path":"/blogs","result":{"data":{"allPost":{"nodes":[{"__typename":"MdxPost","slug":"/co-与异步的一些思考","title":"co 与异步的一些思考","date":"19.03.2020","excerpt":"JavaScript 的异步编程发展经过了四个阶段： 回调函数、发布订阅 Promise co 自执行的 Generator 函数 async / await 第三阶段现在基本不用了，但也起到了承上启下的作用 📝 co 源码 co 接收一个 generator…","timeToRead":2,"description":"通过对 co 源码的探索，进一步思考，得到异步解决方案的本质思路，一切竟然如此简单","tags":[{"name":"SourceCode","slug":"source-code"},{"name":"Thinking","slug":"thinking"},{"name":"Async","slug":"async"}]},{"__typename":"MdxPost","slug":"/koa-2-源码分析","title":"Koa2 源码分析","date":"12.03.2020","excerpt":"Koa 由 express 同一个团队打造，目的是代替 express 成为下一代 Node.js 后端框架，Koa 由于十分简洁，其实更适合做一些框架的基础（egg.js、think.js），如今看来并不能代替 express，express…","timeToRead":2,"description":"深入 Koa2 源码，探寻 Koa2 异步中间件机制","tags":[{"name":"SourceCode","slug":"source-code"}]},{"__typename":"MdxPost","slug":"/读《-7-周-7-语言》-ruby","title":"读《7 周 7 语言》- Ruby","date":"27.02.2020","excerpt":"Ruby 解释执行 无需声明变量 每条代码都有返回值 纯面向对象，“真一切皆为对象” 简洁的判断语句： order.calculate_tax unless order.nil? 鸭子类型 符号 代码块（匿名函数） yield 代码块 &block 闭包 类 Mixin…","timeToRead":1,"description":"《7 周 7 语言》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《7 周 7 语言》","slug":"《-7-周-7-语言》"}]},{"__typename":"MdxPost","slug":"/读《-7-周-7-语言》-io","title":"读《7 周 7 语言》- Io","date":"27.02.2020","excerpt":"Io Io 语法只不过把消息全部串联起来，每个消息都返回一个对象，每条消息都也都带有括号内的可选参数\nIo 中，一切皆为消息，且每条消息都会返回另一条接受消息的对象\nIo…","timeToRead":1,"description":"《7 周 7 语言》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《7 周 7 语言》","slug":"《-7-周-7-语言》"}]},{"__typename":"MdxPost","slug":"/读《-7-周-7-语言》-prolog","title":"读《7 周 7 语言》- Prolog","date":"27.02.2020","excerpt":"Prolog 逻辑编程语言，不是通过算法来解决逻辑问题 基本构造单元：事实、规则、查询 常量小写开头，变量大写开头 例：地图着色 递归 列表长度可变  [1, 2, 3] ，元组长度不可变  (1, 2, 3) 例：八皇后、数独 think 逻辑 编程","timeToRead":1,"description":"《7 周 7 语言》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《7 周 7 语言》","slug":"《-7-周-7-语言》"}]},{"__typename":"MdxPost","slug":"/读《深入浅出-rx-js》-rx-js-驱动-react","title":"读《深入浅出 RxJS》- RxJS 驱动 React","date":"22.02.2020","excerpt":"使用 Subject 类似 EventBus 实现数据交互 Rx 实现 Redux","timeToRead":1,"description":"《深入浅出 RxJS》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《深入浅出 RxJS》","slug":"《深入浅出-rx-js》"}]},{"__typename":"MdxPost","slug":"/读《深入浅出-rx-js》-掌握时间的-scheduler","title":"读《深入浅出 RxJS》- 掌握时间的 Scheduler","date":"21.02.2020","excerpt":"数据结构：它知道如何根据优先级或其他条件存储和排队任务 执行环境：表示执行任务的位置和时间（例如同步、宏任务、微任务、下一动画帧） 虚拟时钟：通过 Scheduler 上的 now 提供“时间”的概念，在特定的任务将仅遵守该时钟指示的时间","timeToRead":1,"description":"《深入浅出 RxJS》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《深入浅出 RxJS》","slug":"《深入浅出-rx-js》"}]},{"__typename":"MdxPost","slug":"/读《深入浅出-rx-js》-多播","title":"读《深入浅出 RxJS》- 多播","date":"20.02.2020","excerpt":"多播就是让一个数据流的内容被多个 Observer 订阅 Subject BehaviorSubject ReplaySubject AsyncSubject 数据流的多播 单播 多播 广播 广播会影响全局环境，筛选消息的责任在接收方，同时多个广播时容易混乱，所以 RxJS…","timeToRead":1,"description":"《深入浅出 RxJS》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《深入浅出 RxJS》","slug":"《深入浅出-rx-js》"}]},{"__typename":"MdxPost","slug":"/读《深入浅出-rx-js》-异常错误处理","title":"读《深入浅出 RxJS》- 异常错误处理","date":"19.02.2020","excerpt":"异常处理的难点 虽然必要，但会让代码更加复杂 try / catch  只支持同步，因为 try / catch 是同步执行，执行后里面的异步代码还没有执行，就抓不到异步代码的错误 因此出现 callback，通过传递 cb…","timeToRead":1,"description":"《深入浅出 RxJS》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《深入浅出 RxJS》","slug":"《深入浅出-rx-js》"}]},{"__typename":"MdxPost","slug":"/读《深入浅出-rx-js》-转化数据流","title":"读《深入浅出 RxJS》- 转化数据流","date":"18.02.2020","excerpt":"转化类操作符 对每个数据进行转化，映射 不转化单个数据，而是把数据重新组合，比如上游传下来 1、2、3 传给下游  1, 2, 3 ，无损回压控制 映射 map project 中的 this 指向 thisArg，相当于一个 context…","timeToRead":1,"description":"《深入浅出 RxJS》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《深入浅出 RxJS》","slug":"《深入浅出-rx-js》"}]},{"__typename":"MdxPost","slug":"/读《深入浅出-rx-js》-过滤类数据流","title":"读《深入浅出 RxJS》- 过滤类数据流","date":"17.02.2020","excerpt":"过滤类操作符 filter first、last take 限定上游数据数量 takeLast takeLast 只有确定上游数据完结的时候才能产生数据，而且是一次性产生所有数据 takeWhile takeUntil Emits the values emitted by…","timeToRead":1,"description":"《深入浅出 RxJS》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《深入浅出 RxJS》","slug":"《深入浅出-rx-js》"}]},{"__typename":"MdxPost","slug":"/读《深入浅出-rx-js》-辅助类数据流","title":"读《深入浅出 RxJS》- 辅助类数据流","date":"16.02.2020","excerpt":"数学类操作符 这些操作符必定会遍历上游 Observable 对象中吐出的所有数据才给下游传递数据，也就是说，它们只有在上游完结的时候，才给下游传递唯一数据 count 统计数据个数 max、min reduce 规约 条件布尔类操作符 every find、findIndex…","timeToRead":1,"description":"《深入浅出 RxJS》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《深入浅出 RxJS》","slug":"《深入浅出-rx-js》"}]},{"__typename":"MdxPost","slug":"/读《深入浅出-rx-js》-合并数据流","title":"读《深入浅出 RxJS》- 合并数据流","date":"15.02.2020","excerpt":"合并类操作符 concat 首尾相连 concat 先从第一个 Observable 对象获取数据，第一个 Observable 就是调用 concat 的那个对象（类似  [1, 2].concat([3, 4]) ），第一个 complete 之后 concat…","timeToRead":1,"description":"《深入浅出 RxJS》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《深入浅出 RxJS》","slug":"《深入浅出-rx-js》"}]},{"__typename":"MdxPost","slug":"/读《深入浅出-rx-js》-创建数据流","title":"读《深入浅出 RxJS》- 创建数据流","date":"14.02.2020","excerpt":"RxJS 提供的创建类操作符覆盖了几乎所有的数据流创建模式，没有必要重复发明轮子 创建同步操作流 产生哪些数据 数据之间先后顺序 create of 列举数据 of 产生 Cold Observable range 指定范围 range 只能每次递增 1，range(1.5,…","timeToRead":1,"description":"《深入浅出 RxJS》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《深入浅出 RxJS》","slug":"《深入浅出-rx-js》"}]},{"__typename":"MdxPost","slug":"/读《深入浅出-rx-js》-操作符基础","title":"读《深入浅出 RxJS》- 操作符基础","date":"13.02.2020","excerpt":"操作符其实就是解决某个具体应用问题的模式。当我们要用 RxJS 解决问题时，首先需要创建 Observable…","timeToRead":1,"description":"《深入浅出 RxJS》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《深入浅出 RxJS》","slug":"《深入浅出-rx-js》"}]},{"__typename":"MdxPost","slug":"/读《深入浅出-rx-js》-入门","title":"读《深入浅出 RxJS》- 入门","date":"12.02.2020","excerpt":"RxJS overview…","timeToRead":1,"description":"《深入浅出 RxJS》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《深入浅出 RxJS》","slug":"《深入浅出-rx-js》"}]},{"__typename":"MdxPost","slug":"/读《大话数据结构》","title":"读《大话数据结构》","date":"12.02.2020","excerpt":"…","timeToRead":7,"description":"《大话数据结构》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《大话数据结构》","slug":"《大话数据结构》"}]},{"__typename":"MdxPost","slug":"/读《-my-sql-必知必会》","title":"读《MySQL 必知必会》","date":"05.01.2020","excerpt":"主键：一列（或一组列），其值能够唯一区分表中每个行 任意两行都不具有相同的主键值 每一行都必须具有一个主键（不为 NULL…","timeToRead":1,"description":"《MySQL 必知必会》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《MySQL 必知必会》","slug":"《-my-sql-必知必会》"}]},{"__typename":"MdxPost","slug":"/redux-源码分析","title":"Redux 源码分析","date":"07.12.2019","excerpt":"随着前端应用逐渐变大，状态也越来越复杂，需要一种状态管理的方案，Redux 就是其中一种 总结起来 React 状态管理方案就分为两类： 外部 Model，通过事件修改状态，组件通过监听订阅状态（通过 Context 连接 React） Redux Mobx EventBus…","timeToRead":1,"description":"深入 Redux 源码","tags":[{"name":"SourceCode","slug":"source-code"}]},{"__typename":"MdxPost","slug":"/读《前端性能优化原理与实践》-应用","title":"读《前端性能优化原理与实践》- 应用","date":"24.08.2019","excerpt":"Lazy-Load 事件的节流（throttle）与防抖（debounce） scroll 事件，resize 事件、鼠标事件（比如 mousemove、mouseover 等）、键盘事件（keyup、keydown…","timeToRead":1,"description":"《前端性能优化原理与实践》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《前端性能优化原理与实践》","slug":"《前端性能优化原理与实践》"}]},{"__typename":"MdxPost","slug":"/读《前端性能优化原理与实践》-渲染","title":"读《前端性能优化原理与实践》- 渲染","date":"23.08.2019","excerpt":"SSR 本该浏览器做的事情，分担给服务器去做 优点： SEO 首屏渲染 缺点： 服务器压力大 在实践中，我一般会建议大家先忘记服务端渲染这个事情——服务器稀少而宝贵，但首屏渲染体验和 SEO…","timeToRead":1,"description":"《前端性能优化原理与实践》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《前端性能优化原理与实践》","slug":"《前端性能优化原理与实践》"}]},{"__typename":"MdxPost","slug":"/读《前端性能优化原理与实践》-http-存储优化","title":"读《前端性能优化原理与实践》- http-存储优化","date":"22.08.2019","excerpt":"浏览器缓存 浏览器缓存机制有四个方面，它们按照获取资源时请求的优先级依次排列如下： Memory Cache Service Worker Cache HTTP Cache Push Cache（HTTP2 的新特性） Memory Cache…","timeToRead":3,"description":"《前端性能优化原理与实践》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《前端性能优化原理与实践》","slug":"《前端性能优化原理与实践》"}]},{"__typename":"MdxPost","slug":"/读《前端性能优化原理与实践》-http-请求优化","title":"读《前端性能优化原理与实践》- http 请求优化","date":"21.08.2019","excerpt":"HTTP 优化有两个大的方向： 减少请求次数 减少单次请求所花费的时间 Http 压缩 HTTP 压缩就是以缩小体积为目的，对 HTTP 内容进行重新编码的过程 压缩 Gzip，服务端要花时间；解压 Gzip，浏览器要花时间，所以不是极端迷你的超小型文件，都建议试试 Gzip…","timeToRead":1,"description":"《前端性能优化原理与实践》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《前端性能优化原理与实践》","slug":"《前端性能优化原理与实践》"}]},{"__typename":"MdxPost","slug":"/读《前端性能优化原理与实践》-开篇","title":"读《前端性能优化原理与实践》- 开篇","date":"20.08.2019","excerpt":"从输入 URL 到页面加载完成，发生了什么？ DNS 解析 TCP 连接 HTTP 请求抛出 服务端处理请求，HTTP…","timeToRead":1,"description":"《前端性能优化原理与实践》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《前端性能优化原理与实践》","slug":"《前端性能优化原理与实践》"}]},{"__typename":"MdxPost","slug":"/读《-java-script-设计模式与开发实践》-适配器模式","title":"读《JavaScript 设计模式与开发实践》- 适配器模式","date":"15.07.2019","excerpt":"适配器模式别名叫包装器，作用是解决两个软件实体间的接口不兼容的问题。使用适配器模式之后，原本由于接口不兼容而不能工作的两个软件实体可以一起工作 通过适配器适配接口 假设我们正在编写一个渲染地图的页面。目前从第三方资源里获得了城市以及它们所对应的 ID…","timeToRead":1,"description":"《JavaScript 设计模式与开发实践》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《JavaScript 设计模式与开发实践》","slug":"《-java-script-设计模式与开发实践》"}]},{"__typename":"MdxPost","slug":"/读《-java-script-设计模式与开发实践》-状态模式","title":"读《JavaScript 设计模式与开发实践》- 状态模式","date":"14.07.2019","excerpt":"…","timeToRead":1,"description":"《JavaScript 设计模式与开发实践》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《JavaScript 设计模式与开发实践》","slug":"《-java-script-设计模式与开发实践》"}]},{"__typename":"MdxPost","slug":"/读《-java-script-设计模式与开发实践》-装饰器模式","title":"读《JavaScript 设计模式与开发实践》- 装饰器模式","date":"13.07.2019","excerpt":"…","timeToRead":1,"description":"《JavaScript 设计模式与开发实践》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《JavaScript 设计模式与开发实践》","slug":"《-java-script-设计模式与开发实践》"}]},{"__typename":"MdxPost","slug":"/读《-java-script-设计模式与开发实践》-中介者模式","title":"读《JavaScript 设计模式与开发实践》- 中介者模式","date":"12.07.2019","excerpt":"…","timeToRead":1,"description":"《JavaScript 设计模式与开发实践》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《JavaScript 设计模式与开发实践》","slug":"《-java-script-设计模式与开发实践》"}]},{"__typename":"MdxPost","slug":"/读《-java-script-设计模式与开发实践》-职责链模式","title":"读《JavaScript 设计模式与开发实践》- 职责链模式","date":"11.07.2019","excerpt":"使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止 职责链模式的最大优点：请求发送者只需要知道链中的第一个节点，从而弱化了发送者和一组接收者之间的强联系 无论是作用域链、原型链，还是DOM…","timeToRead":1,"description":"《JavaScript 设计模式与开发实践》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《JavaScript 设计模式与开发实践》","slug":"《-java-script-设计模式与开发实践》"}]},{"__typename":"MdxPost","slug":"/读《-java-script-设计模式与开发实践》-享元模式","title":"读《JavaScript 设计模式与开发实践》- 享元模式","date":"10.07.2019","excerpt":"享元（flyweight）模式是一种用于性能优化的模式，“fly…","timeToRead":1,"description":"《JavaScript 设计模式与开发实践》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《JavaScript 设计模式与开发实践》","slug":"《-java-script-设计模式与开发实践》"}]},{"__typename":"MdxPost","slug":"/读《-java-script-设计模式与开发实践》-模版方法模式","title":"读《JavaScript 设计模式与开发实践》- 模版方法模式","date":"09.07.2019","excerpt":"模板方法模式由两部分结构组成，第一部分是抽象父类，第二部分是具体的实现子类。通常在抽象父类中封装了子类的算法框架，包括实现一些公共方法以及封装子类中所有方法的执行顺序。子类通过继承这个抽象类，也继承了整个算法结构，并且可以选择重写父类的方法。 Coffee or Tea…","timeToRead":1,"description":"《JavaScript 设计模式与开发实践》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《JavaScript 设计模式与开发实践》","slug":"《-java-script-设计模式与开发实践》"}]},{"__typename":"MdxPost","slug":"/读《-java-script-设计模式与开发实践》-组合模式","title":"读《JavaScript 设计模式与开发实践》- 组合模式","date":"08.07.2019","excerpt":"…","timeToRead":1,"description":"《JavaScript 设计模式与开发实践》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《JavaScript 设计模式与开发实践》","slug":"《-java-script-设计模式与开发实践》"}]},{"__typename":"MdxPost","slug":"/读《-java-script-设计模式与开发实践》-命令模式","title":"读《JavaScript 设计模式与开发实践》- 命令模式","date":"07.07.2019","excerpt":"命令模式是最简单和优雅的模式之一，命令模式中的命令（command…","timeToRead":1,"description":"《JavaScript 设计模式与开发实践》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《JavaScript 设计模式与开发实践》","slug":"《-java-script-设计模式与开发实践》"}]},{"__typename":"MdxPost","slug":"/读《-java-script-设计模式与开发实践》-发布订阅模式","title":"读《JavaScript 设计模式与开发实践》- 发布订阅模式","date":"06.07.2019","excerpt":"发布—订阅模式又叫观察者模式，它定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知。在JavaScript…","timeToRead":1,"description":"《JavaScript 设计模式与开发实践》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《JavaScript 设计模式与开发实践》","slug":"《-java-script-设计模式与开发实践》"}]},{"__typename":"MdxPost","slug":"/读《-java-script-设计模式与开发实践》-迭代器模式","title":"读《JavaScript 设计模式与开发实践》- 迭代器模式","date":"05.07.2019","excerpt":"迭代器模式是指提供一种方法顺序访问一个聚合对象中的各个元素，而又不需要暴露该对象的内部表示。 迭代器模式可以把迭代的过程从业务逻辑中分离出来，在使用迭代器模式之后，即使不关心对象的内部构造，也可以按顺序访问其中的每个元素。 内部迭代器 forEach, map, reduce…","timeToRead":1,"description":"《JavaScript 设计模式与开发实践》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《JavaScript 设计模式与开发实践》","slug":"《-java-script-设计模式与开发实践》"}]},{"__typename":"MdxPost","slug":"/读《-java-script-设计模式与开发实践》-代理模式","title":"读《JavaScript 设计模式与开发实践》- 代理模式","date":"04.07.2019","excerpt":"代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问 保护代理与虚拟代理 保护代理：代理帮主体过滤掉一些请求 虚拟代理：把一些开销很大的对象，延迟到真正需要它的时候才去创建 虚拟代理实现图片预加载 图片加载完成前的 loading…","timeToRead":1,"description":"《JavaScript 设计模式与开发实践》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《JavaScript 设计模式与开发实践》","slug":"《-java-script-设计模式与开发实践》"}]},{"__typename":"MdxPost","slug":"/读《-java-script-设计模式与开发实践》-策略模式","title":"读《JavaScript 设计模式与开发实践》- 策略模式","date":"03.07.2019","excerpt":"…","timeToRead":1,"description":"《JavaScript 设计模式与开发实践》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《JavaScript 设计模式与开发实践》","slug":"《-java-script-设计模式与开发实践》"}]},{"__typename":"MdxPost","slug":"/读《-java-script-设计模式与开发实践》-单例模式","title":"读《JavaScript 设计模式与开发实践》- 单例模式","date":"02.07.2019","excerpt":"保证一个类仅有一个实例，并提供一个访问它的全局访问点 有一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的window对象等 只能通过 Singleton.getInstance 来获取，不能通过 new…","timeToRead":1,"description":"《JavaScript 设计模式与开发实践》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《JavaScript 设计模式与开发实践》","slug":"《-java-script-设计模式与开发实践》"}]},{"__typename":"MdxPost","slug":"/读《-java-script-设计模式与开发实践》-设计原则","title":"读《JavaScript 设计模式与开发实践》- 设计原则","date":"01.07.2019","excerpt":"设计准则 《UNIX/LINUX 设计哲学》 小即是美 每一个程序只做好一件事 快速建立原型 舍弃高效率而取可移植性 采用纯文本来存储数据（可读性，不用二进制存） 充分利用软件的杠杆效应（软件复用） 使用 shell…","timeToRead":1,"description":"《JavaScript 设计模式与开发实践》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《JavaScript 设计模式与开发实践》","slug":"《-java-script-设计模式与开发实践》"}]},{"__typename":"MdxPost","slug":"/读《高性能-java-script》","title":"读《高性能 JavaScript》","date":"20.06.2019","excerpt":"加载与执行 放到 body 底部 脚本解析和执行会阻塞页面渲染 减少脚本(请求)数量 脚本的 defer, async 属性 都是并行下载，不阻塞页面，defer 需等页面加载好后执行，async 是自动执行defer…","timeToRead":1,"description":"《高性能 JavaScript》读书笔记","tags":[{"name":"Note","slug":"note"},{"name":"《高性能 JavaScript》","slug":"《高性能-java-script》"}]}]}},"pageContext":{"formatString":"DD.MM.YYYY"}}}